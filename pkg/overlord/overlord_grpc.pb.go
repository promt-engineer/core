// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v5.28.2
// source: pkg/overlord/overlord.proto

package overlord

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Overlord_InitUserState_FullMethodName                          = "/overlord.Overlord/InitUserState"
	Overlord_GetStateBySessionToken_FullMethodName                 = "/overlord.Overlord/GetStateBySessionToken"
	Overlord_OpenBet_FullMethodName                                = "/overlord.Overlord/OpenBet"
	Overlord_OpenFreeBet_FullMethodName                            = "/overlord.Overlord/OpenFreeBet"
	Overlord_CloseBet_FullMethodName                               = "/overlord.Overlord/CloseBet"
	Overlord_RollbackBet_FullMethodName                            = "/overlord.Overlord/RollbackBet"
	Overlord_AtomicBet_FullMethodName                              = "/overlord.Overlord/AtomicBet"
	Overlord_GetAvailableCurrencies_FullMethodName                 = "/overlord.Overlord/GetAvailableCurrencies"
	Overlord_GetIntegratorConfig_FullMethodName                    = "/overlord.Overlord/GetIntegratorConfig"
	Overlord_GetAvailableFreeBets_FullMethodName                   = "/overlord.Overlord/GetAvailableFreeBets"
	Overlord_CancelAvailableFreeBets_FullMethodName                = "/overlord.Overlord/CancelAvailableFreeBets"
	Overlord_GetAvailableFreeBetsWithIntegratorBet_FullMethodName  = "/overlord.Overlord/GetAvailableFreeBetsWithIntegratorBet"
	Overlord_CancelAvailableFreeBetsByIntegratorBet_FullMethodName = "/overlord.Overlord/CancelAvailableFreeBetsByIntegratorBet"
	Overlord_GetIntegratorFreeSpinsByID_FullMethodName             = "/overlord.Overlord/GetIntegratorFreeSpinsByID"
	Overlord_SaveDefaultWagerInFreeBetValue_FullMethodName         = "/overlord.Overlord/SaveDefaultWagerInFreeBetValue"
	Overlord_AddFreeBets_FullMethodName                            = "/overlord.Overlord/AddFreeBets"
	Overlord_CancelFreeBets_FullMethodName                         = "/overlord.Overlord/CancelFreeBets"
	Overlord_SaveParams_FullMethodName                             = "/overlord.Overlord/SaveParams"
	Overlord_GetParams_FullMethodName                              = "/overlord.Overlord/GetParams"
	Overlord_HealthCheck_FullMethodName                            = "/overlord.Overlord/HealthCheck"
)

// OverlordClient is the client API for Overlord service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OverlordClient interface {
	InitUserState(ctx context.Context, in *InitUserStateIn, opts ...grpc.CallOption) (*InitUserStateOut, error)
	GetStateBySessionToken(ctx context.Context, in *GetStateBySessionTokenIn, opts ...grpc.CallOption) (*InitUserStateOut, error)
	OpenBet(ctx context.Context, in *OpenBetIn, opts ...grpc.CallOption) (*OpenBetOut, error)
	OpenFreeBet(ctx context.Context, in *OpenFreeBetIn, opts ...grpc.CallOption) (*OpenBetOut, error)
	CloseBet(ctx context.Context, in *CloseBetIn, opts ...grpc.CallOption) (*CloseBetOut, error)
	RollbackBet(ctx context.Context, in *RollbackIn, opts ...grpc.CallOption) (*RollbackOut, error)
	AtomicBet(ctx context.Context, in *AtomicBetIn, opts ...grpc.CallOption) (*AtomicBetOut, error)
	GetAvailableCurrencies(ctx context.Context, in *GetAvailableCurrenciesIn, opts ...grpc.CallOption) (*GetAvailableCurrenciesOut, error)
	GetIntegratorConfig(ctx context.Context, in *GetIntegratorConfigIn, opts ...grpc.CallOption) (*GetIntegratorConfigOut, error)
	GetAvailableFreeBets(ctx context.Context, in *GetAvailableFreeBetsIn, opts ...grpc.CallOption) (*GetAvailableFreeBetsOut, error)
	CancelAvailableFreeBets(ctx context.Context, in *CancelAvailableFreeBetsIn, opts ...grpc.CallOption) (*CancelAvailableFreeBetsOut, error)
	GetAvailableFreeBetsWithIntegratorBet(ctx context.Context, in *GetAvailableFreeBetsIn, opts ...grpc.CallOption) (*GetAvailableFreeBetsWithIntegratorBetOut, error)
	CancelAvailableFreeBetsByIntegratorBet(ctx context.Context, in *CancelAvailableFreeBetsByIntegratorBetIn, opts ...grpc.CallOption) (*CancelAvailableFreeBetsOut, error)
	GetIntegratorFreeSpinsByID(ctx context.Context, in *GetIntegratorFreeSpinsByIDIn, opts ...grpc.CallOption) (*GetAvailableFreeBetsOut, error)
	SaveDefaultWagerInFreeBetValue(ctx context.Context, in *SaveDefaultWagerInFreeBetValueIn, opts ...grpc.CallOption) (*SaveDefaultWagerInFreeBetValueOut, error)
	AddFreeBets(ctx context.Context, in *AddFreeBetIn, opts ...grpc.CallOption) (*AddFreeBetOut, error)
	CancelFreeBets(ctx context.Context, in *CancelFreeBetIn, opts ...grpc.CallOption) (*CancelFreeBetOut, error)
	SaveParams(ctx context.Context, in *SaveParamsIn, opts ...grpc.CallOption) (*SaveParamsOut, error)
	GetParams(ctx context.Context, in *GetParamsIn, opts ...grpc.CallOption) (*GetParamsOut, error)
	HealthCheck(ctx context.Context, opts ...grpc.CallOption) (Overlord_HealthCheckClient, error)
}

type overlordClient struct {
	cc grpc.ClientConnInterface
}

func NewOverlordClient(cc grpc.ClientConnInterface) OverlordClient {
	return &overlordClient{cc}
}

func (c *overlordClient) InitUserState(ctx context.Context, in *InitUserStateIn, opts ...grpc.CallOption) (*InitUserStateOut, error) {
	out := new(InitUserStateOut)
	err := c.cc.Invoke(ctx, Overlord_InitUserState_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overlordClient) GetStateBySessionToken(ctx context.Context, in *GetStateBySessionTokenIn, opts ...grpc.CallOption) (*InitUserStateOut, error) {
	out := new(InitUserStateOut)
	err := c.cc.Invoke(ctx, Overlord_GetStateBySessionToken_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overlordClient) OpenBet(ctx context.Context, in *OpenBetIn, opts ...grpc.CallOption) (*OpenBetOut, error) {
	out := new(OpenBetOut)
	err := c.cc.Invoke(ctx, Overlord_OpenBet_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overlordClient) OpenFreeBet(ctx context.Context, in *OpenFreeBetIn, opts ...grpc.CallOption) (*OpenBetOut, error) {
	out := new(OpenBetOut)
	err := c.cc.Invoke(ctx, Overlord_OpenFreeBet_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overlordClient) CloseBet(ctx context.Context, in *CloseBetIn, opts ...grpc.CallOption) (*CloseBetOut, error) {
	out := new(CloseBetOut)
	err := c.cc.Invoke(ctx, Overlord_CloseBet_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overlordClient) RollbackBet(ctx context.Context, in *RollbackIn, opts ...grpc.CallOption) (*RollbackOut, error) {
	out := new(RollbackOut)
	err := c.cc.Invoke(ctx, Overlord_RollbackBet_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overlordClient) AtomicBet(ctx context.Context, in *AtomicBetIn, opts ...grpc.CallOption) (*AtomicBetOut, error) {
	out := new(AtomicBetOut)
	err := c.cc.Invoke(ctx, Overlord_AtomicBet_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overlordClient) GetAvailableCurrencies(ctx context.Context, in *GetAvailableCurrenciesIn, opts ...grpc.CallOption) (*GetAvailableCurrenciesOut, error) {
	out := new(GetAvailableCurrenciesOut)
	err := c.cc.Invoke(ctx, Overlord_GetAvailableCurrencies_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overlordClient) GetIntegratorConfig(ctx context.Context, in *GetIntegratorConfigIn, opts ...grpc.CallOption) (*GetIntegratorConfigOut, error) {
	out := new(GetIntegratorConfigOut)
	err := c.cc.Invoke(ctx, Overlord_GetIntegratorConfig_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overlordClient) GetAvailableFreeBets(ctx context.Context, in *GetAvailableFreeBetsIn, opts ...grpc.CallOption) (*GetAvailableFreeBetsOut, error) {
	out := new(GetAvailableFreeBetsOut)
	err := c.cc.Invoke(ctx, Overlord_GetAvailableFreeBets_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overlordClient) CancelAvailableFreeBets(ctx context.Context, in *CancelAvailableFreeBetsIn, opts ...grpc.CallOption) (*CancelAvailableFreeBetsOut, error) {
	out := new(CancelAvailableFreeBetsOut)
	err := c.cc.Invoke(ctx, Overlord_CancelAvailableFreeBets_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overlordClient) GetAvailableFreeBetsWithIntegratorBet(ctx context.Context, in *GetAvailableFreeBetsIn, opts ...grpc.CallOption) (*GetAvailableFreeBetsWithIntegratorBetOut, error) {
	out := new(GetAvailableFreeBetsWithIntegratorBetOut)
	err := c.cc.Invoke(ctx, Overlord_GetAvailableFreeBetsWithIntegratorBet_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overlordClient) CancelAvailableFreeBetsByIntegratorBet(ctx context.Context, in *CancelAvailableFreeBetsByIntegratorBetIn, opts ...grpc.CallOption) (*CancelAvailableFreeBetsOut, error) {
	out := new(CancelAvailableFreeBetsOut)
	err := c.cc.Invoke(ctx, Overlord_CancelAvailableFreeBetsByIntegratorBet_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overlordClient) GetIntegratorFreeSpinsByID(ctx context.Context, in *GetIntegratorFreeSpinsByIDIn, opts ...grpc.CallOption) (*GetAvailableFreeBetsOut, error) {
	out := new(GetAvailableFreeBetsOut)
	err := c.cc.Invoke(ctx, Overlord_GetIntegratorFreeSpinsByID_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overlordClient) SaveDefaultWagerInFreeBetValue(ctx context.Context, in *SaveDefaultWagerInFreeBetValueIn, opts ...grpc.CallOption) (*SaveDefaultWagerInFreeBetValueOut, error) {
	out := new(SaveDefaultWagerInFreeBetValueOut)
	err := c.cc.Invoke(ctx, Overlord_SaveDefaultWagerInFreeBetValue_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overlordClient) AddFreeBets(ctx context.Context, in *AddFreeBetIn, opts ...grpc.CallOption) (*AddFreeBetOut, error) {
	out := new(AddFreeBetOut)
	err := c.cc.Invoke(ctx, Overlord_AddFreeBets_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overlordClient) CancelFreeBets(ctx context.Context, in *CancelFreeBetIn, opts ...grpc.CallOption) (*CancelFreeBetOut, error) {
	out := new(CancelFreeBetOut)
	err := c.cc.Invoke(ctx, Overlord_CancelFreeBets_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overlordClient) SaveParams(ctx context.Context, in *SaveParamsIn, opts ...grpc.CallOption) (*SaveParamsOut, error) {
	out := new(SaveParamsOut)
	err := c.cc.Invoke(ctx, Overlord_SaveParams_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overlordClient) GetParams(ctx context.Context, in *GetParamsIn, opts ...grpc.CallOption) (*GetParamsOut, error) {
	out := new(GetParamsOut)
	err := c.cc.Invoke(ctx, Overlord_GetParams_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *overlordClient) HealthCheck(ctx context.Context, opts ...grpc.CallOption) (Overlord_HealthCheckClient, error) {
	stream, err := c.cc.NewStream(ctx, &Overlord_ServiceDesc.Streams[0], Overlord_HealthCheck_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &overlordHealthCheckClient{stream}
	return x, nil
}

type Overlord_HealthCheckClient interface {
	Send(*Status) error
	Recv() (*Status, error)
	grpc.ClientStream
}

type overlordHealthCheckClient struct {
	grpc.ClientStream
}

func (x *overlordHealthCheckClient) Send(m *Status) error {
	return x.ClientStream.SendMsg(m)
}

func (x *overlordHealthCheckClient) Recv() (*Status, error) {
	m := new(Status)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// OverlordServer is the server API for Overlord service.
// All implementations should embed UnimplementedOverlordServer
// for forward compatibility
type OverlordServer interface {
	InitUserState(context.Context, *InitUserStateIn) (*InitUserStateOut, error)
	GetStateBySessionToken(context.Context, *GetStateBySessionTokenIn) (*InitUserStateOut, error)
	OpenBet(context.Context, *OpenBetIn) (*OpenBetOut, error)
	OpenFreeBet(context.Context, *OpenFreeBetIn) (*OpenBetOut, error)
	CloseBet(context.Context, *CloseBetIn) (*CloseBetOut, error)
	RollbackBet(context.Context, *RollbackIn) (*RollbackOut, error)
	AtomicBet(context.Context, *AtomicBetIn) (*AtomicBetOut, error)
	GetAvailableCurrencies(context.Context, *GetAvailableCurrenciesIn) (*GetAvailableCurrenciesOut, error)
	GetIntegratorConfig(context.Context, *GetIntegratorConfigIn) (*GetIntegratorConfigOut, error)
	GetAvailableFreeBets(context.Context, *GetAvailableFreeBetsIn) (*GetAvailableFreeBetsOut, error)
	CancelAvailableFreeBets(context.Context, *CancelAvailableFreeBetsIn) (*CancelAvailableFreeBetsOut, error)
	GetAvailableFreeBetsWithIntegratorBet(context.Context, *GetAvailableFreeBetsIn) (*GetAvailableFreeBetsWithIntegratorBetOut, error)
	CancelAvailableFreeBetsByIntegratorBet(context.Context, *CancelAvailableFreeBetsByIntegratorBetIn) (*CancelAvailableFreeBetsOut, error)
	GetIntegratorFreeSpinsByID(context.Context, *GetIntegratorFreeSpinsByIDIn) (*GetAvailableFreeBetsOut, error)
	SaveDefaultWagerInFreeBetValue(context.Context, *SaveDefaultWagerInFreeBetValueIn) (*SaveDefaultWagerInFreeBetValueOut, error)
	AddFreeBets(context.Context, *AddFreeBetIn) (*AddFreeBetOut, error)
	CancelFreeBets(context.Context, *CancelFreeBetIn) (*CancelFreeBetOut, error)
	SaveParams(context.Context, *SaveParamsIn) (*SaveParamsOut, error)
	GetParams(context.Context, *GetParamsIn) (*GetParamsOut, error)
	HealthCheck(Overlord_HealthCheckServer) error
}

// UnimplementedOverlordServer should be embedded to have forward compatible implementations.
type UnimplementedOverlordServer struct {
}

func (UnimplementedOverlordServer) InitUserState(context.Context, *InitUserStateIn) (*InitUserStateOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InitUserState not implemented")
}
func (UnimplementedOverlordServer) GetStateBySessionToken(context.Context, *GetStateBySessionTokenIn) (*InitUserStateOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStateBySessionToken not implemented")
}
func (UnimplementedOverlordServer) OpenBet(context.Context, *OpenBetIn) (*OpenBetOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenBet not implemented")
}
func (UnimplementedOverlordServer) OpenFreeBet(context.Context, *OpenFreeBetIn) (*OpenBetOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OpenFreeBet not implemented")
}
func (UnimplementedOverlordServer) CloseBet(context.Context, *CloseBetIn) (*CloseBetOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseBet not implemented")
}
func (UnimplementedOverlordServer) RollbackBet(context.Context, *RollbackIn) (*RollbackOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RollbackBet not implemented")
}
func (UnimplementedOverlordServer) AtomicBet(context.Context, *AtomicBetIn) (*AtomicBetOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AtomicBet not implemented")
}
func (UnimplementedOverlordServer) GetAvailableCurrencies(context.Context, *GetAvailableCurrenciesIn) (*GetAvailableCurrenciesOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAvailableCurrencies not implemented")
}
func (UnimplementedOverlordServer) GetIntegratorConfig(context.Context, *GetIntegratorConfigIn) (*GetIntegratorConfigOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIntegratorConfig not implemented")
}
func (UnimplementedOverlordServer) GetAvailableFreeBets(context.Context, *GetAvailableFreeBetsIn) (*GetAvailableFreeBetsOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAvailableFreeBets not implemented")
}
func (UnimplementedOverlordServer) CancelAvailableFreeBets(context.Context, *CancelAvailableFreeBetsIn) (*CancelAvailableFreeBetsOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelAvailableFreeBets not implemented")
}
func (UnimplementedOverlordServer) GetAvailableFreeBetsWithIntegratorBet(context.Context, *GetAvailableFreeBetsIn) (*GetAvailableFreeBetsWithIntegratorBetOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAvailableFreeBetsWithIntegratorBet not implemented")
}
func (UnimplementedOverlordServer) CancelAvailableFreeBetsByIntegratorBet(context.Context, *CancelAvailableFreeBetsByIntegratorBetIn) (*CancelAvailableFreeBetsOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelAvailableFreeBetsByIntegratorBet not implemented")
}
func (UnimplementedOverlordServer) GetIntegratorFreeSpinsByID(context.Context, *GetIntegratorFreeSpinsByIDIn) (*GetAvailableFreeBetsOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIntegratorFreeSpinsByID not implemented")
}
func (UnimplementedOverlordServer) SaveDefaultWagerInFreeBetValue(context.Context, *SaveDefaultWagerInFreeBetValueIn) (*SaveDefaultWagerInFreeBetValueOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveDefaultWagerInFreeBetValue not implemented")
}
func (UnimplementedOverlordServer) AddFreeBets(context.Context, *AddFreeBetIn) (*AddFreeBetOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddFreeBets not implemented")
}
func (UnimplementedOverlordServer) CancelFreeBets(context.Context, *CancelFreeBetIn) (*CancelFreeBetOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelFreeBets not implemented")
}
func (UnimplementedOverlordServer) SaveParams(context.Context, *SaveParamsIn) (*SaveParamsOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SaveParams not implemented")
}
func (UnimplementedOverlordServer) GetParams(context.Context, *GetParamsIn) (*GetParamsOut, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetParams not implemented")
}
func (UnimplementedOverlordServer) HealthCheck(Overlord_HealthCheckServer) error {
	return status.Errorf(codes.Unimplemented, "method HealthCheck not implemented")
}

// UnsafeOverlordServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OverlordServer will
// result in compilation errors.
type UnsafeOverlordServer interface {
	mustEmbedUnimplementedOverlordServer()
}

func RegisterOverlordServer(s grpc.ServiceRegistrar, srv OverlordServer) {
	s.RegisterService(&Overlord_ServiceDesc, srv)
}

func _Overlord_InitUserState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitUserStateIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverlordServer).InitUserState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Overlord_InitUserState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverlordServer).InitUserState(ctx, req.(*InitUserStateIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Overlord_GetStateBySessionToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStateBySessionTokenIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverlordServer).GetStateBySessionToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Overlord_GetStateBySessionToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverlordServer).GetStateBySessionToken(ctx, req.(*GetStateBySessionTokenIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Overlord_OpenBet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenBetIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverlordServer).OpenBet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Overlord_OpenBet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverlordServer).OpenBet(ctx, req.(*OpenBetIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Overlord_OpenFreeBet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OpenFreeBetIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverlordServer).OpenFreeBet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Overlord_OpenFreeBet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverlordServer).OpenFreeBet(ctx, req.(*OpenFreeBetIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Overlord_CloseBet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseBetIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverlordServer).CloseBet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Overlord_CloseBet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverlordServer).CloseBet(ctx, req.(*CloseBetIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Overlord_RollbackBet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RollbackIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverlordServer).RollbackBet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Overlord_RollbackBet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverlordServer).RollbackBet(ctx, req.(*RollbackIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Overlord_AtomicBet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AtomicBetIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverlordServer).AtomicBet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Overlord_AtomicBet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverlordServer).AtomicBet(ctx, req.(*AtomicBetIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Overlord_GetAvailableCurrencies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAvailableCurrenciesIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverlordServer).GetAvailableCurrencies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Overlord_GetAvailableCurrencies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverlordServer).GetAvailableCurrencies(ctx, req.(*GetAvailableCurrenciesIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Overlord_GetIntegratorConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIntegratorConfigIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverlordServer).GetIntegratorConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Overlord_GetIntegratorConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverlordServer).GetIntegratorConfig(ctx, req.(*GetIntegratorConfigIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Overlord_GetAvailableFreeBets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAvailableFreeBetsIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverlordServer).GetAvailableFreeBets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Overlord_GetAvailableFreeBets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverlordServer).GetAvailableFreeBets(ctx, req.(*GetAvailableFreeBetsIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Overlord_CancelAvailableFreeBets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelAvailableFreeBetsIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverlordServer).CancelAvailableFreeBets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Overlord_CancelAvailableFreeBets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverlordServer).CancelAvailableFreeBets(ctx, req.(*CancelAvailableFreeBetsIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Overlord_GetAvailableFreeBetsWithIntegratorBet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAvailableFreeBetsIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverlordServer).GetAvailableFreeBetsWithIntegratorBet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Overlord_GetAvailableFreeBetsWithIntegratorBet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverlordServer).GetAvailableFreeBetsWithIntegratorBet(ctx, req.(*GetAvailableFreeBetsIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Overlord_CancelAvailableFreeBetsByIntegratorBet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelAvailableFreeBetsByIntegratorBetIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverlordServer).CancelAvailableFreeBetsByIntegratorBet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Overlord_CancelAvailableFreeBetsByIntegratorBet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverlordServer).CancelAvailableFreeBetsByIntegratorBet(ctx, req.(*CancelAvailableFreeBetsByIntegratorBetIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Overlord_GetIntegratorFreeSpinsByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIntegratorFreeSpinsByIDIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverlordServer).GetIntegratorFreeSpinsByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Overlord_GetIntegratorFreeSpinsByID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverlordServer).GetIntegratorFreeSpinsByID(ctx, req.(*GetIntegratorFreeSpinsByIDIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Overlord_SaveDefaultWagerInFreeBetValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveDefaultWagerInFreeBetValueIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverlordServer).SaveDefaultWagerInFreeBetValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Overlord_SaveDefaultWagerInFreeBetValue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverlordServer).SaveDefaultWagerInFreeBetValue(ctx, req.(*SaveDefaultWagerInFreeBetValueIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Overlord_AddFreeBets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddFreeBetIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverlordServer).AddFreeBets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Overlord_AddFreeBets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverlordServer).AddFreeBets(ctx, req.(*AddFreeBetIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Overlord_CancelFreeBets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelFreeBetIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverlordServer).CancelFreeBets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Overlord_CancelFreeBets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverlordServer).CancelFreeBets(ctx, req.(*CancelFreeBetIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Overlord_SaveParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaveParamsIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverlordServer).SaveParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Overlord_SaveParams_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverlordServer).SaveParams(ctx, req.(*SaveParamsIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Overlord_GetParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetParamsIn)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OverlordServer).GetParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Overlord_GetParams_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OverlordServer).GetParams(ctx, req.(*GetParamsIn))
	}
	return interceptor(ctx, in, info, handler)
}

func _Overlord_HealthCheck_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(OverlordServer).HealthCheck(&overlordHealthCheckServer{stream})
}

type Overlord_HealthCheckServer interface {
	Send(*Status) error
	Recv() (*Status, error)
	grpc.ServerStream
}

type overlordHealthCheckServer struct {
	grpc.ServerStream
}

func (x *overlordHealthCheckServer) Send(m *Status) error {
	return x.ServerStream.SendMsg(m)
}

func (x *overlordHealthCheckServer) Recv() (*Status, error) {
	m := new(Status)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Overlord_ServiceDesc is the grpc.ServiceDesc for Overlord service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Overlord_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "overlord.Overlord",
	HandlerType: (*OverlordServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InitUserState",
			Handler:    _Overlord_InitUserState_Handler,
		},
		{
			MethodName: "GetStateBySessionToken",
			Handler:    _Overlord_GetStateBySessionToken_Handler,
		},
		{
			MethodName: "OpenBet",
			Handler:    _Overlord_OpenBet_Handler,
		},
		{
			MethodName: "OpenFreeBet",
			Handler:    _Overlord_OpenFreeBet_Handler,
		},
		{
			MethodName: "CloseBet",
			Handler:    _Overlord_CloseBet_Handler,
		},
		{
			MethodName: "RollbackBet",
			Handler:    _Overlord_RollbackBet_Handler,
		},
		{
			MethodName: "AtomicBet",
			Handler:    _Overlord_AtomicBet_Handler,
		},
		{
			MethodName: "GetAvailableCurrencies",
			Handler:    _Overlord_GetAvailableCurrencies_Handler,
		},
		{
			MethodName: "GetIntegratorConfig",
			Handler:    _Overlord_GetIntegratorConfig_Handler,
		},
		{
			MethodName: "GetAvailableFreeBets",
			Handler:    _Overlord_GetAvailableFreeBets_Handler,
		},
		{
			MethodName: "CancelAvailableFreeBets",
			Handler:    _Overlord_CancelAvailableFreeBets_Handler,
		},
		{
			MethodName: "GetAvailableFreeBetsWithIntegratorBet",
			Handler:    _Overlord_GetAvailableFreeBetsWithIntegratorBet_Handler,
		},
		{
			MethodName: "CancelAvailableFreeBetsByIntegratorBet",
			Handler:    _Overlord_CancelAvailableFreeBetsByIntegratorBet_Handler,
		},
		{
			MethodName: "GetIntegratorFreeSpinsByID",
			Handler:    _Overlord_GetIntegratorFreeSpinsByID_Handler,
		},
		{
			MethodName: "SaveDefaultWagerInFreeBetValue",
			Handler:    _Overlord_SaveDefaultWagerInFreeBetValue_Handler,
		},
		{
			MethodName: "AddFreeBets",
			Handler:    _Overlord_AddFreeBets_Handler,
		},
		{
			MethodName: "CancelFreeBets",
			Handler:    _Overlord_CancelFreeBets_Handler,
		},
		{
			MethodName: "SaveParams",
			Handler:    _Overlord_SaveParams_Handler,
		},
		{
			MethodName: "GetParams",
			Handler:    _Overlord_GetParams_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "HealthCheck",
			Handler:       _Overlord_HealthCheck_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "pkg/overlord/overlord.proto",
}
